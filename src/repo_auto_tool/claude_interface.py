"""Wrapper for Claude Code CLI interactions.

This module provides a Python interface to the Claude Code CLI tool,
handling subprocess execution, JSON parsing, session management,
and automatic retry with exponential backoff for transient failures.

Includes circuit breaker pattern for fault tolerance - prevents
cascading failures when Claude API is experiencing issues.
"""

import json
import logging
import random
import subprocess
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from .circuit_breaker import (
    CircuitBreaker,
    CircuitBreakerConfig,
    get_circuit_breaker,
)
from .exceptions import ClaudeNotFoundError, ClaudeResponseError, ClaudeTimeoutError

logger = logging.getLogger(__name__)


@dataclass
class TokenUsage:
    """Token usage statistics from a Claude API call.

    Tracks input tokens, output tokens, and cache statistics for
    cost monitoring and efficiency optimization.

    Attributes:
        input_tokens: Number of tokens in the prompt/context.
        output_tokens: Number of tokens generated by Claude.
        cache_read_tokens: Tokens read from cache (reduced cost).
        cache_creation_tokens: Tokens written to cache.
    """
    input_tokens: int = 0
    output_tokens: int = 0
    cache_read_tokens: int = 0
    cache_creation_tokens: int = 0

    @property
    def total_tokens(self) -> int:
        """Total tokens used (input + output)."""
        return self.input_tokens + self.output_tokens

    def to_dict(self) -> dict[str, int]:
        """Convert to dictionary for serialization."""
        return {
            "input_tokens": self.input_tokens,
            "output_tokens": self.output_tokens,
            "cache_read_tokens": self.cache_read_tokens,
            "cache_creation_tokens": self.cache_creation_tokens,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "TokenUsage":
        """Create TokenUsage from a dictionary.

        Handles missing fields gracefully by defaulting to 0.
        """
        return cls(
            input_tokens=data.get("input_tokens", 0),
            output_tokens=data.get("output_tokens", 0),
            cache_read_tokens=data.get("cache_read_tokens", 0),
            cache_creation_tokens=data.get("cache_creation_tokens", 0),
        )

    def __add__(self, other: "TokenUsage") -> "TokenUsage":
        """Add two TokenUsage instances together."""
        if not isinstance(other, TokenUsage):
            return NotImplemented
        return TokenUsage(
            input_tokens=self.input_tokens + other.input_tokens,
            output_tokens=self.output_tokens + other.output_tokens,
            cache_read_tokens=self.cache_read_tokens + other.cache_read_tokens,
            cache_creation_tokens=self.cache_creation_tokens + other.cache_creation_tokens,
        )


def _parse_token_usage(raw_output: dict[str, Any] | None) -> TokenUsage:
    """Extract token usage from Claude CLI JSON output.

    The Claude CLI returns token usage in various formats depending on version.
    This function handles multiple possible structures gracefully.

    Args:
        raw_output: The raw JSON output from Claude CLI.

    Returns:
        TokenUsage with extracted values, or empty TokenUsage if not found.
    """
    if not raw_output:
        return TokenUsage()

    # Try common locations for usage data in Claude CLI output
    usage_data: dict[str, Any] = {}

    # Direct "usage" field
    if "usage" in raw_output and isinstance(raw_output["usage"], dict):
        usage_data = raw_output["usage"]
    # Nested in "metadata" or "stats"
    elif "metadata" in raw_output and isinstance(raw_output["metadata"], dict):
        usage_data = raw_output["metadata"].get("usage", {})
    elif "stats" in raw_output and isinstance(raw_output["stats"], dict):
        usage_data = raw_output["stats"]
    # Cost report field (some CLI versions)
    elif "cost_usd" in raw_output or "total_cost" in raw_output:
        # Extract from top-level if tokens are there
        usage_data = raw_output

    return TokenUsage(
        input_tokens=_safe_int(usage_data.get("input_tokens")),
        output_tokens=_safe_int(usage_data.get("output_tokens")),
        cache_read_tokens=_safe_int(
            usage_data.get("cache_read_tokens")
            or usage_data.get("cache_read_input_tokens")
        ),
        cache_creation_tokens=_safe_int(
            usage_data.get("cache_creation_tokens")
            or usage_data.get("cache_creation_input_tokens")
        ),
    )


def _safe_int(value: Any) -> int:
    """Safely convert a value to int, returning 0 on failure."""
    if value is None:
        return 0
    try:
        return int(value)
    except (ValueError, TypeError):
        return 0


# Retry configuration constants
DEFAULT_MAX_RETRIES = 3
DEFAULT_BASE_DELAY = 1.0  # seconds
DEFAULT_MAX_DELAY = 60.0  # seconds
DEFAULT_BACKOFF_MULTIPLIER = 2.0
DEFAULT_JITTER_FACTOR = 0.25  # +/- 25% jitter


def _calculate_backoff_delay(
    attempt: int,
    base_delay: float = DEFAULT_BASE_DELAY,
    max_delay: float = DEFAULT_MAX_DELAY,
    multiplier: float = DEFAULT_BACKOFF_MULTIPLIER,
    jitter_factor: float = DEFAULT_JITTER_FACTOR,
) -> float:
    """Calculate exponential backoff delay with jitter.

    Args:
        attempt: Current retry attempt (0-indexed).
        base_delay: Initial delay in seconds.
        max_delay: Maximum delay cap in seconds.
        multiplier: Exponential multiplier for each attempt.
        jitter_factor: Random jitter factor (0.25 = +/- 25%).

    Returns:
        Delay in seconds with jitter applied.
    """
    # Calculate exponential delay
    delay = base_delay * (multiplier ** attempt)

    # Cap at max_delay
    delay = min(delay, max_delay)

    # Apply jitter: random value in range [delay * (1 - jitter), delay * (1 + jitter)]
    jitter_range = delay * jitter_factor
    delay = delay + random.uniform(-jitter_range, jitter_range)

    # Ensure non-negative
    return max(0.0, delay)


def _is_retryable_error(error: str | None, returncode: int | None) -> bool:
    """Determine if an error is transient and worth retrying.

    Args:
        error: Error message string.
        returncode: Process return code.

    Returns:
        True if the error appears transient and retryable.
    """
    if error is None:
        return False

    error_lower = error.lower()

    # Network/connection errors (transient)
    transient_patterns = [
        "connection",
        "timeout",
        "network",
        "econnreset",
        "econnrefused",
        "etimedout",
        "rate limit",
        "too many requests",
        "429",
        "503",
        "502",
        "504",
        "overloaded",
        "temporarily unavailable",
        "service unavailable",
        "internal server error",
        "500",
    ]

    for pattern in transient_patterns:
        if pattern in error_lower:
            return True

    # Specific return codes that may be transient
    if returncode is not None and returncode in (1, 75, 124):
        # 75 = temp failure, 124 = timeout on some systems
        return True

    return False


@dataclass
class ClaudeResponse:
    """Structured response from Claude Code CLI.

    Attributes:
        success: Whether the call completed successfully.
        result: The text result from Claude.
        raw_output: The raw JSON output from the CLI (if available).
        error: Error message if the call failed.
        session_id: Session ID for resuming conversations.
        usage: Token usage statistics for this call.
        model_used: The model that was used for this call (if known).
    """
    success: bool
    result: str
    raw_output: dict[str, Any] | None = None
    error: str | None = None
    session_id: str | None = None
    usage: TokenUsage = field(default_factory=TokenUsage)
    model_used: str | None = None
    

class ClaudeCodeInterface:
    """
    Interface to Claude Code CLI for scripted/agentic use.

    Claude Code CAN and WILL edit files directly when given permission.
    This is the core mechanism for the self-improving loop.

    Features circuit breaker pattern for fault tolerance:
    - After repeated failures, temporarily stops making requests
    - Prevents cascading failures and wasted API calls
    - Automatically recovers when Claude API becomes healthy
    """

    def __init__(
        self,
        working_dir: Path,
        allowed_tools: list[str] | None = None,
        model: str | None = None,
        timeout: int = 600,
        max_retries: int = DEFAULT_MAX_RETRIES,
        use_circuit_breaker: bool = True,
        verbose: bool = False,
    ):
        self.working_dir = Path(working_dir).resolve()
        self.verbose = verbose
        self.allowed_tools = allowed_tools or [
            "Bash(*)",      # Run any shell command
            "Read(*)",      # Read any file
            "Edit(*)",      # Edit any file (THIS IS THE KEY ONE)
            "Write(*)",     # Create new files
            "Glob(*)",      # Find files by pattern
            "Grep(*)",      # Search file contents
        ]
        self.model = model
        self.timeout = timeout
        self.max_retries = max_retries
        self.session_id: str | None = None
        self.use_circuit_breaker = use_circuit_breaker

        # Initialize circuit breaker for fault tolerance
        # Uses shared instance from registry for consistent state across interfaces
        self._circuit_breaker: CircuitBreaker[ClaudeResponse] | None = None
        if use_circuit_breaker:
            self._circuit_breaker = self._create_circuit_breaker()

        self._verify_cli()

    def _create_circuit_breaker(self) -> CircuitBreaker[ClaudeResponse]:
        """Create or get the circuit breaker for Claude API calls.

        Uses higher thresholds and longer timeout suitable for API calls.
        The circuit opens after 3 consecutive failures and waits 2 minutes
        before allowing test requests through again.

        Returns:
            CircuitBreaker configured for Claude API operations.
        """
        config = CircuitBreakerConfig(
            failure_threshold=3,  # Open after 3 consecutive failures
            success_threshold=1,  # Close after 1 success in half-open
            timeout=120.0,  # Wait 2 minutes before testing recovery
            half_open_max_calls=1,  # Allow 1 test call at a time
        )
        return get_circuit_breaker("claude_api", config)
    
    def _verify_cli(self) -> None:
        """Verify Claude Code CLI is installed and accessible.

        Raises:
            ClaudeNotFoundError: If the Claude CLI is not installed or not in PATH.
            ClaudeResponseError: If the CLI returns an error on version check.
        """
        try:
            result = subprocess.run(
                ["claude", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode != 0:
                raise ClaudeResponseError(
                    reason="CLI version check failed",
                    raw_output=result.stderr
                )
            logger.info(f"Claude CLI version: {result.stdout.strip()}")
        except FileNotFoundError as err:
            raise ClaudeNotFoundError() from err
    
    def _build_command(
        self,
        prompt: str,
        max_turns: int | None = None,
        resume: bool = False,
        model_override: str | None = None,
    ) -> tuple[list[str], str | None]:
        """Build the claude CLI command.

        Args:
            prompt: The prompt to send.
            max_turns: Maximum agentic turns (unused, for future).
            resume: Whether to resume from previous session.
            model_override: Optional model to use instead of default.

        Returns:
            Tuple of (command list, model being used).
        """
        cmd = [
            "claude",
            "-p", prompt,                          # Non-interactive prompt mode
            "--output-format", "stream-json",             # Machine-readable output
            "--dangerously-skip-permissions",      # Auto-accept all tool use
            "--allowedTools", ",".join(self.allowed_tools),
        ]

        # Determine which model to use
        effective_model = model_override or self.model
        if effective_model:
            cmd.extend(["--model", effective_model])

        # Resume previous session for context continuity
        if resume and self.session_id:
            cmd.extend(["--resume", self.session_id])

        # Note: max_turns not directly supported, handled by model
        _ = max_turns

        return cmd, effective_model
    
    def _execute_single_call(
        self,
        cmd: list[str],
        prompt_preview: str = "",
        model_used: str | None = None,
    ) -> ClaudeResponse:
        """Execute a single Claude CLI call with streaming output.

        Uses Popen to stream output in real-time so users can see what Claude
        is doing. Parses stream-json format line by line.

        Args:
            cmd: The command list to execute.
            prompt_preview: First 100 chars of prompt for error context.
            model_used: The model being used for this call.

        Returns:
            ClaudeResponse from this single execution attempt.
        """
        import sys
        import threading
        import time

        collected_output: list[dict[str, Any]] = []
        result_text = ""
        final_result: dict[str, Any] = {}
        stderr_output = ""
        return_code = 0

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8",
                errors="replace",  # Handle invalid UTF-8 gracefully
                cwd=self.working_dir,
            )

            # Read stderr in background thread
            def read_stderr():
                nonlocal stderr_output
                if process.stderr:
                    stderr_output = process.stderr.read()

            stderr_thread = threading.Thread(target=read_stderr)
            stderr_thread.start()

            start_time = time.time()

            # Stream stdout line by line
            if process.stdout:
                for line in process.stdout:
                    # Check timeout
                    if time.time() - start_time > self.timeout:
                        process.kill()
                        raise subprocess.TimeoutExpired(cmd, self.timeout)

                    line = line.strip()
                    if not line:
                        continue

                    try:
                        data = json.loads(line)
                        collected_output.append(data)

                        # Display meaningful updates to the user
                        msg_type = data.get("type", "")

                        if msg_type == "assistant":
                            # Claude is thinking/responding
                            content = data.get("message", {}).get("content", [])
                            for block in content:
                                if isinstance(block, dict):
                                    if block.get("type") == "text":
                                        text = block.get("text", "")
                                        if text:
                                            if self.verbose:
                                                print(f"  Claude: {text}")
                                            else:
                                                # Truncate in normal mode
                                                display = text[:500]
                                                if len(text) > 500:
                                                    display += "..."
                                                print(f"  Claude: {display}")
                                            result_text += text + "\n"
                                    elif block.get("type") == "tool_use":
                                        tool = block.get("name", "unknown")
                                        tool_input = block.get("input", {})
                                        if self.verbose and tool_input:
                                            if tool == "Edit":
                                                fp = tool_input.get("file_path", "")
                                                print(f"  [Edit: {fp}]")
                                            elif tool == "Read":
                                                fp = tool_input.get("file_path", "")
                                                print(f"  [Read: {fp}]")
                                            elif tool == "Bash":
                                                cmd = tool_input.get("command", "")[:80]
                                                print(f"  [Bash: {cmd}]")
                                            else:
                                                print(f"  [{tool}]")
                                        else:
                                            print(f"  [{tool}]")

                        elif msg_type == "tool_result":
                            if self.verbose:
                                content = data.get("content", "")
                                if content and len(str(content)) < 300:
                                    print(f"  -> {content}")

                        elif msg_type == "result":
                            # Final result
                            final_result = data
                            if data.get("result"):
                                result_text = str(data.get("result"))
                            self.session_id = data.get("session_id")

                        elif msg_type == "error":
                            error_msg = data.get("error", {})
                            if isinstance(error_msg, dict):
                                print(f"  Error: {error_msg.get('message', 'Unknown')}")
                            else:
                                print(f"  Error: {error_msg}")

                        sys.stdout.flush()

                    except json.JSONDecodeError:
                        # Non-JSON line, might be plain text
                        if line:
                            print(f"  {line}")

            # Wait for process and stderr thread
            return_code = process.wait()
            stderr_thread.join(timeout=5)

            # Parse final result
            usage = _parse_token_usage(final_result)

            # If no explicit result text, check if files were changed
            if not result_text.strip() and return_code == 0:
                result_text = "Claude completed (check git diff for changes)"

            return ClaudeResponse(
                success=return_code == 0,
                result=result_text.strip() or "Completed",
                raw_output=final_result or {"collected": collected_output},
                session_id=self.session_id,
                usage=usage,
                model_used=model_used,
            )

        except subprocess.TimeoutExpired:
            timeout_error = ClaudeTimeoutError(self.timeout, prompt_preview)
            logger.error(str(timeout_error))
            return ClaudeResponse(
                success=False,
                result="",
                error=f"Timeout after {self.timeout}s",
                model_used=model_used,
            )
        except OSError as e:
            logger.error(f"OS error executing Claude CLI: {e}")
            return ClaudeResponse(
                success=False,
                result="",
                error=f"OS error: {e}",
                model_used=model_used,
            )
        except Exception as e:
            logger.exception(f"Unexpected error executing Claude CLI: {e}")
            return ClaudeResponse(
                success=False,
                result="",
                error=f"Unexpected error: {e}",
                model_used=model_used,
            )

    def call(
        self,
        prompt: str,
        context: str | None = None,
        max_turns: int | None = None,
        resume: bool = False,
        model_override: str | None = None,
    ) -> ClaudeResponse:
        """Make a call to Claude Code CLI with automatic retry for transient errors.

        Claude WILL edit files in working_dir when instructed.
        Uses exponential backoff with jitter for retries on transient failures.

        If circuit breaker is enabled and open due to repeated failures,
        returns immediately with an error response to prevent further
        wasted API calls.

        Args:
            prompt: The instruction/prompt to send.
            context: Optional context to prepend.
            max_turns: Limit agentic turns (None = unlimited).
            resume: Continue from previous session.
            model_override: Optional model to use instead of default.

        Returns:
            ClaudeResponse with results.
        """
        full_prompt = f"{context}\n\n{prompt}" if context else prompt
        cmd, model_used = self._build_command(full_prompt, max_turns, resume, model_override)

        # Create prompt preview for error context (used in timeout errors)
        prompt_preview = prompt[:100]

        # Check circuit breaker before making the call
        if self._circuit_breaker and self._circuit_breaker.is_open():
            logger.warning(
                "Circuit breaker is OPEN - Claude API appears unhealthy. "
                "Rejecting call to prevent cascading failures."
            )
            stats = self._circuit_breaker.stats
            return ClaudeResponse(
                success=False,
                result="",
                error=(
                    f"Circuit breaker open after {stats.consecutive_failures} failures. "
                    f"API will be tested again shortly."
                ),
                model_used=model_used,
            )

        logger.debug(f"Executing: {' '.join(cmd)}")
        if model_used:
            logger.debug(f"Using model: {model_used}")
        logger.info(f"Prompt: {prompt_preview}...")

        last_response: ClaudeResponse | None = None

        for attempt in range(self.max_retries + 1):
            response = self._execute_single_call(cmd, prompt_preview, model_used)

            # Success - notify circuit breaker and return
            if response.success:
                if self._circuit_breaker:
                    self._circuit_breaker._handle_success()
                if attempt > 0:
                    logger.info(f"Call succeeded on retry attempt {attempt}")
                return response

            # Check if this is a retryable error
            if not _is_retryable_error(response.error, None):
                # Non-retryable error - don't count against circuit breaker
                logger.debug(f"Non-retryable error: {response.error}")
                return response

            # Record failure with circuit breaker
            if self._circuit_breaker:
                # Create an exception to pass to circuit breaker
                exc = ClaudeResponseError(
                    reason=response.error or "Unknown error",
                    raw_output=None,
                )
                self._circuit_breaker._handle_failure(exc)

                # Check if circuit breaker just opened
                if self._circuit_breaker.is_open():
                    logger.error(
                        f"Circuit breaker opened after {attempt + 1} failures. "
                        f"Stopping retries."
                    )
                    return response

            last_response = response

            # Check if we have retries remaining
            if attempt < self.max_retries:
                delay = _calculate_backoff_delay(attempt)
                logger.warning(
                    f"Transient error on attempt {attempt + 1}/{self.max_retries + 1}: "
                    f"{response.error}. Retrying in {delay:.1f}s..."
                )
                time.sleep(delay)
            else:
                logger.error(
                    f"All {self.max_retries + 1} attempts failed. "
                    f"Last error: {response.error}"
                )

        # Return the last failed response
        return last_response or ClaudeResponse(
            success=False,
            result="",
            error="All retry attempts exhausted",
            model_used=model_used,
        )

    def get_circuit_breaker_status(self) -> dict[str, Any] | None:
        """Get the status of the circuit breaker.

        Returns:
            Dictionary with circuit breaker status, or None if disabled.
        """
        if self._circuit_breaker:
            return self._circuit_breaker.get_status_dict()
        return None

    def reset_circuit_breaker(self) -> None:
        """Manually reset the circuit breaker to closed state.

        Use this if you know the Claude API has recovered and want to
        immediately resume operations without waiting for the timeout.
        """
        if self._circuit_breaker:
            self._circuit_breaker.reset()
            logger.info("Circuit breaker manually reset")
    
    def analyze(
        self,
        question: str,
        model_override: str | None = None,
    ) -> ClaudeResponse:
        """Ask Claude to analyze the repo without making changes.

        Args:
            question: The analysis question or prompt.
            model_override: Optional model to use instead of default.

        Returns:
            ClaudeResponse with analysis results.
        """
        return self.call(
            f"ANALYSIS ONLY - Do not edit any files.\n\n{question}",
            max_turns=5,
            model_override=model_override,
        )

    def improve(
        self,
        instruction: str,
        max_turns: int = 10,
        model_override: str | None = None,
    ) -> ClaudeResponse:
        """Ask Claude to make improvements to the repo.

        This WILL edit files.

        Args:
            instruction: The improvement instruction.
            max_turns: Maximum agentic turns.
            model_override: Optional model to use instead of default.

        Returns:
            ClaudeResponse with improvement results.
        """
        return self.call(
            f"Make the following improvements to this codebase:\n\n{instruction}",
            max_turns=max_turns,
            model_override=model_override,
        )
