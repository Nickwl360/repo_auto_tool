"""Pull request generation with AI-generated summaries.

This module handles:
- Generating PR titles and descriptions from commits
- Creating PRs via GitHub CLI (gh) or GitLab CLI (glab)
- Formatting change summaries for reviewers
- Supporting multiple git hosting platforms

All operations are defensively coded with robust error handling.
"""

import logging
import re
import subprocess
import tempfile
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any

from .exceptions import GitOperationError, RepoAutoToolError

logger = logging.getLogger(__name__)


class PRGeneratorError(RepoAutoToolError):
    """Error related to PR generation operations."""

    def __init__(
        self,
        message: str,
        platform: str | None = None,
        details: str | None = None,
    ):
        super().__init__(message)
        self.platform = platform
        self.details = details


class GitPlatform(Enum):
    """Supported git hosting platforms."""

    GITHUB = "github"
    GITLAB = "gitlab"
    BITBUCKET = "bitbucket"
    UNKNOWN = "unknown"


@dataclass
class CommitInfo:
    """Information about a single commit."""

    hash: str  # Short hash
    full_hash: str  # Full hash
    message: str  # Full commit message
    subject: str  # First line of commit message
    author: str
    timestamp: str
    files_changed: list[str] = field(default_factory=list)
    stats: dict[str, int] = field(default_factory=dict)  # insertions, deletions


@dataclass
class PRContent:
    """Generated PR content ready for creation."""

    title: str
    body: str
    base_branch: str
    head_branch: str
    labels: list[str] = field(default_factory=list)
    draft: bool = False
    reviewers: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "title": self.title,
            "body": self.body,
            "base_branch": self.base_branch,
            "head_branch": self.head_branch,
            "labels": self.labels,
            "draft": self.draft,
            "reviewers": self.reviewers,
        }


@dataclass
class PRResult:
    """Result of PR creation."""

    success: bool
    pr_url: str | None = None
    pr_number: int | None = None
    error: str | None = None
    platform: GitPlatform = GitPlatform.UNKNOWN

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "success": self.success,
            "pr_url": self.pr_url,
            "pr_number": self.pr_number,
            "error": self.error,
            "platform": self.platform.value,
        }


class PRGenerator:
    """Generates and creates pull requests with AI-generated summaries.

    Supports GitHub (via gh CLI) and GitLab (via glab CLI).
    All methods are defensively coded to handle errors gracefully.
    """

    # PR body template
    DEFAULT_TEMPLATE = """## Summary

{summary}

## Changes

{changes}

## Commits

{commits}

## Testing

{testing}

---
*Generated by repo-auto-tool*
"""

    # Categorize commits by type
    COMMIT_TYPE_PATTERNS = [
        (r"^feat(\([^)]+\))?:", "Features"),
        (r"^fix(\([^)]+\))?:", "Bug Fixes"),
        (r"^docs(\([^)]+\))?:", "Documentation"),
        (r"^style(\([^)]+\))?:", "Styling"),
        (r"^refactor(\([^)]+\))?:", "Refactoring"),
        (r"^perf(\([^)]+\))?:", "Performance"),
        (r"^test(\([^)]+\))?:", "Tests"),
        (r"^chore(\([^)]+\))?:", "Chores"),
        (r"^build(\([^)]+\))?:", "Build"),
        (r"^ci(\([^)]+\))?:", "CI"),
        (r"^\[repo-improver\]", "Automated Improvements"),
    ]

    def __init__(
        self,
        repo_path: Path,
        platform: GitPlatform | None = None,
    ):
        """Initialize the PR generator.

        Args:
            repo_path: Path to the git repository.
            platform: Git platform to use. If None, auto-detects.
        """
        self.repo_path = Path(repo_path).resolve()
        self.platform = platform or self._detect_platform()
        self._cli_available: dict[str, bool] = {}

    def _run_git(
        self,
        *args: str,
        check: bool = True,
        capture_output: bool = True,
    ) -> subprocess.CompletedProcess[str]:
        """Run a git command safely.

        Args:
            *args: Git command arguments (without 'git' prefix).
            check: If True, raise on non-zero exit.
            capture_output: If True, capture stdout/stderr.

        Returns:
            CompletedProcess result.

        Raises:
            GitOperationError: If check=True and command fails.
        """
        cmd = ["git", *args]
        try:
            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=capture_output,
                text=True,
                check=False,
                timeout=30,
            )
            if check and result.returncode != 0:
                raise GitOperationError(
                    operation=args[0] if args else "unknown",
                    reason=f"Exit code {result.returncode}",
                    output=result.stderr or result.stdout,
                )
            return result
        except subprocess.TimeoutExpired as e:
            raise GitOperationError(
                operation=args[0] if args else "unknown",
                reason="Command timed out",
            ) from e
        except OSError as e:
            raise GitOperationError(
                operation=args[0] if args else "unknown",
                reason=str(e),
            ) from e

    def _detect_platform(self) -> GitPlatform:
        """Detect the git hosting platform from remote URL.

        Returns:
            Detected GitPlatform.
        """
        try:
            result = self._run_git("remote", "get-url", "origin", check=False)
            if result.returncode != 0:
                return GitPlatform.UNKNOWN

            url = result.stdout.strip().lower()
            if "github" in url:
                return GitPlatform.GITHUB
            elif "gitlab" in url:
                return GitPlatform.GITLAB
            elif "bitbucket" in url:
                return GitPlatform.BITBUCKET
            return GitPlatform.UNKNOWN
        except Exception as e:
            logger.debug(f"Failed to detect platform: {e}")
            return GitPlatform.UNKNOWN

    def _is_cli_available(self, cli_name: str) -> bool:
        """Check if a CLI tool is available.

        Args:
            cli_name: Name of CLI tool (e.g., "gh", "glab").

        Returns:
            True if available.
        """
        if cli_name in self._cli_available:
            return self._cli_available[cli_name]

        try:
            result = subprocess.run(
                [cli_name, "--version"],
                capture_output=True,
                text=True,
                check=False,
                timeout=5,
            )
            available = result.returncode == 0
        except (OSError, subprocess.TimeoutExpired):
            available = False

        self._cli_available[cli_name] = available
        return available

    def get_commits(
        self,
        base_branch: str = "main",
        head_branch: str | None = None,
        max_commits: int = 100,
    ) -> list[CommitInfo]:
        """Get commits between branches.

        Args:
            base_branch: Base branch to compare against.
            head_branch: Head branch (default: current branch).
            max_commits: Maximum number of commits to retrieve.

        Returns:
            List of CommitInfo objects.
        """
        commits: list[CommitInfo] = []

        # Get current branch if head not specified
        if head_branch is None:
            try:
                result = self._run_git("rev-parse", "--abbrev-ref", "HEAD")
                head_branch = result.stdout.strip()
            except GitOperationError:
                head_branch = "HEAD"

        # Get commit log with format: hash|full_hash|author|timestamp|subject
        commit_format = "%h|%H|%an|%ai|%s"
        range_spec = f"{base_branch}..{head_branch}"

        try:
            result = self._run_git(
                "log",
                range_spec,
                f"--format={commit_format}",
                f"-{max_commits}",
                check=False,
            )
            if result.returncode != 0:
                logger.warning(f"Could not get commits: {result.stderr}")
                return commits

            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue

                parts = line.split("|", 4)
                if len(parts) >= 5:
                    commit = CommitInfo(
                        hash=parts[0],
                        full_hash=parts[1],
                        author=parts[2],
                        timestamp=parts[3],
                        subject=parts[4],
                        message=parts[4],  # Will be updated below
                    )
                    commits.append(commit)

            # Get full messages and stats for each commit
            for commit in commits[:20]:  # Limit detailed fetch
                try:
                    # Get full commit message
                    result = self._run_git(
                        "log", "-1", "--format=%B", commit.full_hash, check=False
                    )
                    if result.returncode == 0:
                        commit.message = result.stdout.strip()

                    # Get files changed
                    result = self._run_git(
                        "diff-tree",
                        "--no-commit-id",
                        "--name-only",
                        "-r",
                        commit.full_hash,
                        check=False,
                    )
                    if result.returncode == 0:
                        commit.files_changed = [
                            f for f in result.stdout.strip().split("\n") if f
                        ]

                    # Get stats
                    result = self._run_git(
                        "diff-tree",
                        "--numstat",
                        "--no-commit-id",
                        commit.full_hash,
                        check=False,
                    )
                    if result.returncode == 0:
                        insertions = 0
                        deletions = 0
                        for stat_line in result.stdout.strip().split("\n"):
                            if stat_line:
                                stat_parts = stat_line.split("\t")
                                if len(stat_parts) >= 2:
                                    try:
                                        insertions += int(stat_parts[0])
                                        deletions += int(stat_parts[1])
                                    except ValueError:
                                        pass  # Binary files show as "-"
                        commit.stats = {
                            "insertions": insertions,
                            "deletions": deletions,
                        }
                except Exception as e:
                    logger.debug(f"Failed to get details for {commit.hash}: {e}")

        except Exception as e:
            logger.warning(f"Failed to get commits: {e}")

        return commits

    def _categorize_commits(
        self,
        commits: list[CommitInfo],
    ) -> dict[str, list[CommitInfo]]:
        """Categorize commits by type.

        Args:
            commits: List of commits to categorize.

        Returns:
            Dictionary mapping category to commits.
        """
        categories: dict[str, list[CommitInfo]] = {}

        for commit in commits:
            category = "Other Changes"
            subject_lower = commit.subject.lower()

            for pattern, cat_name in self.COMMIT_TYPE_PATTERNS:
                if re.match(pattern, subject_lower, re.IGNORECASE):
                    category = cat_name
                    break

            if category not in categories:
                categories[category] = []
            categories[category].append(commit)

        return categories

    def _generate_summary(
        self,
        commits: list[CommitInfo],
        goal: str | None = None,
    ) -> str:
        """Generate a summary of the changes.

        Args:
            commits: List of commits to summarize.
            goal: Optional goal description for context.

        Returns:
            Summary text.
        """
        if not commits:
            return "No changes to summarize."

        # Calculate stats
        total_files: set[str] = set()
        total_insertions = 0
        total_deletions = 0

        for commit in commits:
            total_files.update(commit.files_changed)
            total_insertions += commit.stats.get("insertions", 0)
            total_deletions += commit.stats.get("deletions", 0)

        # Categorize commits
        categories = self._categorize_commits(commits)

        # Build summary
        lines = []

        if goal:
            lines.append(f"This PR addresses the goal: **{goal}**")
            lines.append("")

        lines.append(
            f"This PR contains **{len(commits)}** commits "
            f"modifying **{len(total_files)}** files "
            f"(+{total_insertions}/-{total_deletions})."
        )
        lines.append("")

        # Add category summary
        if categories:
            lines.append("### Changes by Type")
            for category, cat_commits in sorted(categories.items()):
                lines.append(f"- **{category}**: {len(cat_commits)} commits")

        return "\n".join(lines)

    def _format_changes(self, commits: list[CommitInfo]) -> str:
        """Format the changes section of the PR body.

        Args:
            commits: List of commits.

        Returns:
            Formatted changes text.
        """
        categories = self._categorize_commits(commits)

        if not categories:
            return "No changes to document."

        lines = []
        for category, cat_commits in sorted(categories.items()):
            lines.append(f"### {category}")
            for commit in cat_commits:
                # Clean up the subject line
                subject = commit.subject
                # Remove conventional commit prefix for cleaner display
                for pattern, _ in self.COMMIT_TYPE_PATTERNS:
                    subject = re.sub(pattern, "", subject, flags=re.IGNORECASE).strip()
                    if subject.startswith(":"):
                        subject = subject[1:].strip()

                lines.append(f"- {subject or commit.subject} (`{commit.hash}`)")
            lines.append("")

        return "\n".join(lines)

    def _format_commits(self, commits: list[CommitInfo]) -> str:
        """Format the commits section of the PR body.

        Args:
            commits: List of commits.

        Returns:
            Formatted commits text.
        """
        if not commits:
            return "No commits."

        lines = []
        for commit in commits[:20]:  # Limit to 20 commits
            files_info = ""
            if commit.files_changed:
                files_info = f" ({len(commit.files_changed)} files)"
            lines.append(f"- `{commit.hash}` - {commit.subject}{files_info}")

        if len(commits) > 20:
            lines.append(f"- ... and {len(commits) - 20} more commits")

        return "\n".join(lines)

    def _generate_testing_section(self, commits: list[CommitInfo]) -> str:
        """Generate the testing section of the PR body.

        Args:
            commits: List of commits.

        Returns:
            Testing section text.
        """
        # Detect test-related commits
        test_commits = [
            c
            for c in commits
            if any(
                keyword in c.subject.lower()
                for keyword in ["test", "spec", "coverage"]
            )
        ]

        lines = []
        if test_commits:
            lines.append("- [ ] Tests included in this PR")
        else:
            lines.append("- [ ] Existing tests pass")

        lines.append("- [ ] Manual testing performed")
        lines.append("- [ ] No new warnings introduced")

        return "\n".join(lines)

    def generate_pr_content(
        self,
        base_branch: str = "main",
        head_branch: str | None = None,
        goal: str | None = None,
        template: str | None = None,
        draft: bool = False,
        labels: list[str] | None = None,
    ) -> PRContent:
        """Generate PR content from commits.

        Args:
            base_branch: Base branch for the PR.
            head_branch: Head branch (default: current branch).
            goal: Optional goal description for context.
            template: Optional custom template.
            draft: Whether to create as draft PR.
            labels: Optional labels to add.

        Returns:
            PRContent ready for creation.
        """
        # Get current branch if not specified
        if head_branch is None:
            try:
                result = self._run_git("rev-parse", "--abbrev-ref", "HEAD")
                head_branch = result.stdout.strip()
            except GitOperationError:
                head_branch = "HEAD"

        # Get commits
        commits = self.get_commits(base_branch, head_branch)

        # Generate title from first commit or goal
        if goal:
            # Clean up goal for title (first sentence, truncated)
            title = goal.split(".")[0].split("\n")[0][:60]
            if len(goal) > 60:
                title += "..."
        elif commits:
            # Use first commit subject, cleaned up
            first_subject = commits[0].subject
            # Remove [repo-improver] prefix if present
            if first_subject.startswith("[repo-improver]"):
                first_subject = first_subject[15:].strip()
            title = first_subject[:60]
            if len(commits[0].subject) > 60:
                title += "..."
        else:
            title = f"Updates from {head_branch}"

        # Generate body sections
        summary = self._generate_summary(commits, goal)
        changes = self._format_changes(commits)
        commit_list = self._format_commits(commits)
        testing = self._generate_testing_section(commits)

        # Format body
        body_template = template or self.DEFAULT_TEMPLATE
        body = body_template.format(
            summary=summary,
            changes=changes,
            commits=commit_list,
            testing=testing,
        )

        # Auto-detect labels from commits
        auto_labels = labels or []
        if not auto_labels:
            categories = self._categorize_commits(commits)
            if "Bug Fixes" in categories:
                auto_labels.append("bug")
            if "Features" in categories:
                auto_labels.append("enhancement")
            if "Documentation" in categories:
                auto_labels.append("documentation")
            if "Automated Improvements" in categories:
                auto_labels.append("automated")

        return PRContent(
            title=title,
            body=body,
            base_branch=base_branch,
            head_branch=head_branch,
            labels=auto_labels,
            draft=draft,
        )

    def create_pr(
        self,
        content: PRContent,
        push_first: bool = True,
    ) -> PRResult:
        """Create a pull request.

        Args:
            content: PR content to create.
            push_first: Whether to push the branch first.

        Returns:
            PRResult with creation status.
        """
        # Push branch if requested
        if push_first:
            try:
                self._run_git(
                    "push", "-u", "origin", content.head_branch, check=True
                )
                logger.info(f"Pushed branch {content.head_branch}")
            except GitOperationError as e:
                # Try force push if regular push fails
                try:
                    self._run_git(
                        "push",
                        "-u",
                        "-f",
                        "origin",
                        content.head_branch,
                        check=True,
                    )
                    logger.info(f"Force pushed branch {content.head_branch}")
                except GitOperationError:
                    return PRResult(
                        success=False,
                        error=f"Failed to push branch: {e.reason}",
                        platform=self.platform,
                    )

        # Create PR based on platform
        if self.platform == GitPlatform.GITHUB:
            return self._create_github_pr(content)
        elif self.platform == GitPlatform.GITLAB:
            return self._create_gitlab_pr(content)
        else:
            return PRResult(
                success=False,
                error=f"Unsupported platform: {self.platform.value}",
                platform=self.platform,
            )

    def _create_github_pr(self, content: PRContent) -> PRResult:
        """Create a GitHub PR using gh CLI.

        Args:
            content: PR content.

        Returns:
            PRResult.
        """
        if not self._is_cli_available("gh"):
            return PRResult(
                success=False,
                error="GitHub CLI (gh) is not installed or not authenticated",
                platform=GitPlatform.GITHUB,
            )

        # Write body to temp file to avoid command line length issues
        try:
            with tempfile.NamedTemporaryFile(
                mode="w",
                suffix=".md",
                delete=False,
                encoding="utf-8",
            ) as f:
                f.write(content.body)
                body_file = f.name

            cmd = [
                "gh",
                "pr",
                "create",
                "--title",
                content.title,
                "--body-file",
                body_file,
                "--base",
                content.base_branch,
                "--head",
                content.head_branch,
            ]

            if content.draft:
                cmd.append("--draft")

            if content.labels:
                for label in content.labels:
                    cmd.extend(["--label", label])

            if content.reviewers:
                for reviewer in content.reviewers:
                    cmd.extend(["--reviewer", reviewer])

            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
            )

            # Clean up temp file
            try:
                Path(body_file).unlink()
            except OSError:
                pass

            if result.returncode != 0:
                return PRResult(
                    success=False,
                    error=result.stderr or result.stdout or "Unknown error",
                    platform=GitPlatform.GITHUB,
                )

            # Parse PR URL from output
            pr_url = result.stdout.strip()
            pr_number = None
            if pr_url:
                match = re.search(r"/pull/(\d+)", pr_url)
                if match:
                    pr_number = int(match.group(1))

            return PRResult(
                success=True,
                pr_url=pr_url,
                pr_number=pr_number,
                platform=GitPlatform.GITHUB,
            )

        except subprocess.TimeoutExpired:
            return PRResult(
                success=False,
                error="PR creation timed out",
                platform=GitPlatform.GITHUB,
            )
        except OSError as e:
            return PRResult(
                success=False,
                error=f"Failed to create PR: {e}",
                platform=GitPlatform.GITHUB,
            )

    def _create_gitlab_pr(self, content: PRContent) -> PRResult:
        """Create a GitLab MR using glab CLI.

        Args:
            content: PR content.

        Returns:
            PRResult.
        """
        if not self._is_cli_available("glab"):
            return PRResult(
                success=False,
                error="GitLab CLI (glab) is not installed or not authenticated",
                platform=GitPlatform.GITLAB,
            )

        try:
            # Write body to temp file
            with tempfile.NamedTemporaryFile(
                mode="w",
                suffix=".md",
                delete=False,
                encoding="utf-8",
            ) as f:
                f.write(content.body)
                body_file = f.name

            cmd = [
                "glab",
                "mr",
                "create",
                "--title",
                content.title,
                "--description",
                content.body,  # glab uses --description instead of --body
                "--target-branch",
                content.base_branch,
                "--source-branch",
                content.head_branch,
                "--yes",  # Non-interactive
            ]

            if content.draft:
                cmd.append("--draft")

            if content.labels:
                cmd.extend(["--label", ",".join(content.labels)])

            if content.reviewers:
                cmd.extend(["--reviewer", ",".join(content.reviewers)])

            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=False,
                timeout=60,
            )

            # Clean up temp file
            try:
                Path(body_file).unlink()
            except OSError:
                pass

            if result.returncode != 0:
                return PRResult(
                    success=False,
                    error=result.stderr or result.stdout or "Unknown error",
                    platform=GitPlatform.GITLAB,
                )

            # Parse MR URL from output
            mr_url = None
            mr_number = None
            output = result.stdout.strip()

            # Look for URL in output
            url_match = re.search(r"https?://[^\s]+merge_requests/\d+", output)
            if url_match:
                mr_url = url_match.group(0)
                number_match = re.search(r"merge_requests/(\d+)", mr_url)
                if number_match:
                    mr_number = int(number_match.group(1))

            return PRResult(
                success=True,
                pr_url=mr_url or output,
                pr_number=mr_number,
                platform=GitPlatform.GITLAB,
            )

        except subprocess.TimeoutExpired:
            return PRResult(
                success=False,
                error="MR creation timed out",
                platform=GitPlatform.GITLAB,
            )
        except OSError as e:
            return PRResult(
                success=False,
                error=f"Failed to create MR: {e}",
                platform=GitPlatform.GITLAB,
            )

    def get_pr_preview(
        self,
        base_branch: str = "main",
        head_branch: str | None = None,
        goal: str | None = None,
    ) -> str:
        """Get a preview of the PR without creating it.

        Args:
            base_branch: Base branch.
            head_branch: Head branch.
            goal: Optional goal description.

        Returns:
            Formatted preview text.
        """
        content = self.generate_pr_content(
            base_branch=base_branch,
            head_branch=head_branch,
            goal=goal,
        )

        lines = [
            "=" * 60,
            "PULL REQUEST PREVIEW",
            "=" * 60,
            "",
            f"Title: {content.title}",
            f"Base:  {content.base_branch} <- {content.head_branch}",
            "",
            "Labels:",
        ]

        if content.labels:
            for label in content.labels:
                lines.append(f"  - {label}")
        else:
            lines.append("  (none)")

        lines.extend(["", "Body:", "-" * 40, content.body, "-" * 40])

        return "\n".join(lines)


def create_pr_from_repo(
    repo_path: Path | str,
    base_branch: str = "main",
    head_branch: str | None = None,
    goal: str | None = None,
    draft: bool = False,
    labels: list[str] | None = None,
    push_first: bool = True,
    preview_only: bool = False,
) -> PRResult | str:
    """Convenience function to create a PR from a repository.

    Args:
        repo_path: Path to the repository.
        base_branch: Base branch for the PR.
        head_branch: Head branch (default: current branch).
        goal: Optional goal description for context.
        draft: Whether to create as draft.
        labels: Optional labels.
        push_first: Whether to push branch first.
        preview_only: If True, return preview string instead of creating.

    Returns:
        PRResult if creating, preview string if preview_only.
    """
    generator = PRGenerator(Path(repo_path))

    if preview_only:
        return generator.get_pr_preview(
            base_branch=base_branch,
            head_branch=head_branch,
            goal=goal,
        )

    content = generator.generate_pr_content(
        base_branch=base_branch,
        head_branch=head_branch,
        goal=goal,
        draft=draft,
        labels=labels,
    )

    return generator.create_pr(content, push_first=push_first)
